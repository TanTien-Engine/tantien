import "scene.scene" for Scene
import "scene.scene_stack" for SceneStack
import "graphics.camera2d" for Camera2D as tt_Camera2D
import "gui" for GUI, Context, MOUSE_LEFT, MOUSE_RIGHT, MOUSE_DOWN, MOUSE_UP, MOUSE_MOVE, MOUSE_DRAG
import "blueprint.edit_op" for EditOP as BlueprintEditOP
import "blueprint.node_op" for NodeOP
import "blueprint.blueprint" for Blueprint
import "blueprint.variant" for VAR_TYPE_ANY
import "blueprint.execute_list" for ExecuteList
import "maths.vector" for Vector2
import "graphics" for Graphics, Textbox
import "scene.node" for Node as SceneNode
import "scene.components.boundingbox2" for BoundingBox2
import "scene.components.transform2" for Transform2
import "io" for IO
import "filesystem" for Filesystem
import "editor.operators.node2d_translate" for Node2dTranslate
import "editor.node_cache" for NODE_CACHE
import "system" for System as tt_System
import "maths" for Matrix44
import "image" for ImageData
import "render" for Render, Framebuffer, RenderBuffer
import "blueprint.nodes.*"
import "math" for Math
import "rendergraph.nodes.texture" for Texture
import "rendergraph.nodes.shader_code" for ShaderCode
import "rendergraph.drawlist" for Drawlist
import "rendergraph.rendergraph" for Rendergraph
import "editorgraph.trigger_list" for TriggerList

class Editor
{
	load()
	{
		this.scene_stack = SceneStack()

		this.camera = tt_Camera2D()

		import "blueprint.blackboard" for BLACKBOARD
		BLACKBOARD.editor_cam = this.camera

		this.nodes_op = BlueprintEditOP(this.camera, this.scene_stack, this.popup_cb)
		this.preview_op = NodeOP(this.scene_stack)
		this.editop = this.nodes_op

		this.popup_pos = nil
		this.prev_pin = nil

		this.gui_top = Context.init()
		this.gui_nodes = Context.init()

		this.right_press_pos = nil

//		this.filepath = ""
//		this.filepath = "assets/blueprints/pbrgraph/clearcoat.ves"
		this.filepath = "samples/pbrgraph/nodes/sheen.ves"

		this.hide_nodes = false

		this.popup_nodes = []
		this.all_nodes = {}

		this.script_stack = []

		// copy and paste
		this.clipboard = ""
		this.cam_pos_on_copy = nil

		NODE_CACHE.set_editor(this)

		var tb = Textbox()
		tb.width = 500
		tb.height = 50
		tb.font_size = 48
		tb.font_color = [196, 64, 64, 255]
		tb.align_hori = 2
		tb.align_vert = 1
		this.TB_TITLE = tb

		this.drawlist = nil
		this.exe_list = nil
		this.trigger_list = nil

		Rendergraph.regist()
	}

	clear_popup_nodes()
	{
		this.popup_nodes.clear()
		this.all_nodes.clear()		
	}

	update()
	{
		var scene = this.scene_stack.top()
		scene.update()

		// update aabb
		for (var node in scene.nodes) 
		{
			var bp_node = node.components["bp"]
			if (bp_node.aabb_dirty) {
				node.components["bounding"].set_size(bp_node.get_size())
				bp_node.aabb_dirty = false
			}
		}	

		GUI.update(this.gui_top)
		GUI.update(this.gui_nodes)
	}

	draw()
	{
		this.draw_preview()

		if (!this.hide_nodes) {
			this.draw_scene()
		} else {
			// draw op title
			var node = this.preview_op.get_selected()
			if (node) {
				var x = -Graphics.get_width() * 0.5 + 200
				var y = Graphics.get_height() * 0.5 - 50
				Graphics.draw_text(node.get_class().name, x, y, 1.0, this.TB_TITLE)
			}
		}

		this.editop.draw()

		Graphics.flush()

		this.draw_gui()

		//Graphics.dtex_debug_draw()
	}

	sizechanged(w, h)
	{
		Graphics.on_size(w, h)
		GUI.on_size(w, h)
		this.camera.on_size(w, h)

		var scene = this.scene_stack.top()
		for (var node in scene.nodes) 
		{
			var bp_node = node.components["bp"]
			if (bp_node is Viewport) {
				this.scene_stack.bp_dirty = true
			}
		}
	}

	keypressed(key)
	{
		this.editop.on_key_pressed(key)		

		if (key == "delete") 
		{
			this.scene_stack.bp_dirty = true
			GUI.rebuild(this.gui_nodes)
		} 
		else if (key == "space") 
		{
			this.hide_nodes = !this.hide_nodes
			if (this.hide_nodes) {
				this.editop = this.preview_op
			} else {
				this.editop = this.nodes_op
			}
		}
	}

	keyreleased(key)
	{
		this.editop.on_key_released(key)		
	}

	mousemoved(x, y, btn)
	{
		GUI.mouse_input(this.gui_top, btn, MOUSE_MOVE, x, y, 0, 0, 1)
		GUI.mouse_input(this.gui_nodes, btn, MOUSE_MOVE, x, y, -this.camera.pos.x, -this.camera.pos.y, 1.0/this.camera.scale)

		if (!this.is_gui_active()) {
			this.editop.on_mouse_moved(x, y, btn)
		}
	}

	mousedragged(x, y, btn)
	{
		GUI.mouse_input(this.gui_top, btn, MOUSE_DRAG, x, y, 0, 0, 1)
		GUI.mouse_input(this.gui_nodes, btn, MOUSE_DRAG, x, y, -this.camera.pos.x, -this.camera.pos.y, 1.0/this.camera.scale)

		if (!this.is_gui_active()) {
			this.editop.on_mouse_dragged(x, y, btn)
		}
	}

	mousepressed(x, y, btn)
	{		
		GUI.mouse_input(this.gui_top, btn, MOUSE_DOWN, x, y, 0, 0, 1)
		GUI.mouse_input(this.gui_nodes, btn, MOUSE_DOWN, x, y, -this.camera.pos.x, -this.camera.pos.y, 1.0/this.camera.scale)

		if (btn == MOUSE_RIGHT) {
			this.right_press_pos = Vector2(x, y)
		}

		if (!this.is_gui_active()) {
			this.editop.on_mouse_pressed(x, y, btn)
		}

		if (this.hide_nodes)
		{
			if (btn == MOUSE_LEFT) 
			{
				import "blueprint.blackboard" for BLACKBOARD
				BLACKBOARD.mouse_pos.set(x, y)

				import "editorgraph.event_types" for EVENT_MOUSE_LEFT_DOWN
				this.trigger_list.run(EVENT_MOUSE_LEFT_DOWN)
			}
		}
	}

	mousereleased(x, y, btn)
	{
		GUI.mouse_input(this.gui_top, btn, MOUSE_UP, x, y, 0, 0, 1)
		GUI.mouse_input(this.gui_nodes, btn, MOUSE_UP, x, y, -this.camera.pos.x, -this.camera.pos.y, 1.0/this.camera.scale)

		if (btn == MOUSE_RIGHT and this.right_press_pos.x == x and this.right_press_pos.y == y) {
			this.right_press_pos = nil
			this.popup_pos = Vector2(x, y)
		} else if (btn == MOUSE_LEFT) {
			this.popup_pos = nil
			this.prev_pin = nil
		}

		if (!this.is_gui_active()) {
			this.editop.on_mouse_released(x, y, btn)
		}
	}

	mouseclicked(x, y, btn)
	{
		this.enter_subgraph()
	}

	mousescrolled(x, y, dx, dy)
	{
		this.editop.on_mouse_scrolled(x, y, dx, dy)
	}

	draw_scene()
	{
		var cam_mt = Matrix44.init()
		var s = 1.0 / this.camera.scale
		cam_mt.translate(-this.camera.pos.x, -this.camera.pos.y, 0)
		cam_mt.scale(s, s, 1)

		var scene = this.scene_stack.top()
		scene.draw(cam_mt)

		// fixme
		Graphics.flush()

		GUI.begin(this.gui_nodes)
		var dirty = false
		for (var node in scene.nodes) {
			var bp_node = node.components["bp"]
			if (bp_node.draw_gui(this.gui_nodes)) {
				bp_node.on_gui_dirty()
				dirty = true
			}
		}
		GUI.end(this.gui_nodes)

		if (dirty) {
			this.editop.clear()
		}
	}

	setup_popup_nodes()
	{
		var subgraph = this.scene_stack.top().ud
		if (subgraph) {
			subgraph.setup_popup_nodes(this)
		} else {
			this.prepare_nodes()
		}
	}

	draw_scenes_nav_bar()
	{
		if (this.scene_stack.count() <= 1) {
			return
		}

		var x = - Graphics.get_width() * 0.5 + 20
		var y = Graphics.get_height() * 0.5 - 30
		for (var i in 0..this.scene_stack.scenes.count - 1) 
		{
			var scene = this.scene_stack.scenes[i]
			if (GUI.button(this.gui_top, scene.name, x, y, 0, 0)) 
			{
				while (this.scene_stack.scenes.count > i + 1) 
				{
					var old = this.scene_stack.top()
					old.on_leave_out()

					this.scene_stack.pop()

					var new = this.scene_stack.top()					
					this.filepath = new.filepath
					new.on_enter_in()
				}

				this.setup_popup_nodes()

				return
			}
			x = x + 100
		}
	}

	draw_gui()
	{
		Graphics.on_cam_update(0, 0, 1)

		GUI.begin(this.gui_top)

		if (this.popup_pos)
		{
			var pos = GUI.trans_scr_pos_to_proj(this.popup_pos.x, this.popup_pos.y, 0, 0, 1)
			var new_node = this.draw_popup(pos[0], pos[1] - 25, this.prev_pin)
			if (new_node)
			{
				var pos = GUI.trans_scr_pos_to_proj(this.popup_pos.x, this.popup_pos.y, -this.camera.pos.x, -this.camera.pos.y, 1.0/this.camera.scale)
				this.add_node(new_node, pos[0], pos[1])
				if (this.prev_pin)
				{
					if (this.prev_pin.is_input) 
					{
						if (!new_node.exports.isEmpty) 
						{
							var idx = this.query_matched_pin_idx(this.prev_pin, new_node.exports)
							if (idx >= 0) {
								Blueprint.connect(new_node.exports[idx], this.prev_pin)
								this.scene_stack.bp_dirty = true
							}
						}
					} 
					else 
					{
						if (!new_node.imports.isEmpty) 
						{
							var idx = this.query_matched_pin_idx(this.prev_pin, new_node.imports)
							if (idx >= 0) {
								Blueprint.connect(this.prev_pin, new_node.imports[idx])
								this.scene_stack.bp_dirty = true
							}
						}
					}
				}
				this.popup_pos = nil
				this.prev_pin = nil
			}
		}

		this.draw_scenes_nav_bar()

		// fixme:
		GUI.button(this.gui_top, ".", 9999, 9999, 0, 0)

		GUI.end(this.gui_top)

		Graphics.on_cam_update(this.camera.pos.x, this.camera.pos.y, this.camera.scale)
	}

	query_matched_pin_idx(pin, pins)
	{
		for (var i in 0..pins.count) {
			if (this.is_pin_pin_type_match(pin, pins[i])) {
				return i
			}
		}
		return -1
	}

	is_pin_pin_type_match(a, b)
	{
		var types = []
		if (a.type is List) {
			for (var type in a.type) {
				types.add(type)
			}
		} else {
			types.add(a.type)
		}
		if (types.contains(VAR_TYPE_ANY)) {
			return true
		}

		if (b.type == VAR_TYPE_ANY) {
			return true
		}
		if (b.type is List) {
			for (var type in b.type) {
				if (types.contains(type)) {
					return true
				}				
			}
		} else {
			if (types.contains(b.type)) {
				return true
			}
		}

		return false
	}

	is_pin_node_type_match(pin, node)
	{
		var types = []
		if (pin.type is List) {
			for (var type in pin.type) {
				types.add(type)
			}
		} else {
			types.add(pin.type)
		}
		if (types.contains(VAR_TYPE_ANY)) {
			return true
		}

		var pins
		if (pin.is_input) {
			pins = node.exports
		} else {
			pins = node.imports
		}	
		for (var p in pins) 
		{
			if (p.type == VAR_TYPE_ANY) {
				return true
			}
			if (p.type is List) {
				for (var type in p.type) {
					if (types.contains(type)) {
						return true
					}				
				}
			} else {
				if (types.contains(p.type)) {
					return true
				}
			}
		}

		return false
	}	

	draw_popup(x, y, prev_pin)
	{
		var num = 0
		if (prev_pin)
		{
			for (var node in this.popup_nodes) {
				if (this.is_pin_node_type_match(prev_pin, this.all_nodes[node.get_class().name])) {
					num = num + 1
				}
			}
		}
		else
		{
			num = this.popup_nodes.count
		}

		var ITEM_WIDTH = 120
		var ITEM_HEIGHT = 25
		var Y_MAX = 35

		var frame_w = Math.ceil(num / Y_MAX) * ITEM_WIDTH
		var frame_h = Math.min(num, Y_MAX) * ITEM_HEIGHT
		GUI.frame(this.gui_top, x, y - frame_h + ITEM_HEIGHT, frame_w, frame_h)

		var y_begin = y
		var y_num = 0
		for (var node in this.popup_nodes) 
		{
			var show = true
			if (prev_pin) {
				show = this.is_pin_node_type_match(prev_pin, this.all_nodes[node.get_class().name])
			}
			if (show)
			{
				if (GUI.selectable(this.gui_top, node.get_class().name, false, x, y, ITEM_WIDTH)) {
					return node()
				}
				y = y - ITEM_HEIGHT

				y_num = y_num + 1
				if (y_num == Y_MAX)	{
					x = x + ITEM_WIDTH
					y = y_begin
					y_num = 0
				}
			}
		}
		return nil
	}

	popup_cb(x, y, prev_pin)
	{
		this.popup_pos = Vector2(x, y)
		if (prev_pin) {
			this.prev_pin = prev_pin
		}
	}

	clear_popup_nodes()
	{
			
	}

	add_popup_node(node)
	{
		this.popup_nodes.add(node)
		this.all_nodes[node.get_class().name] = node()
	}

	is_gui_active()
	{
		return this.popup_pos != nil
	}

	add_node(bp_node, x, y)
	{
		var node = SceneNode()

		node.components["bp"] = bp_node

		var pos = Vector2(x, y)

		var bb = BoundingBox2(bp_node.get_size())
		bb.transform(pos, 0, Vector2())
		node.components["bounding"] = bb
		bp_node.aabb_dirty = false

		var trans = Transform2()
		trans.set_position(pos)
		node.components["transform"] = trans

		this.scene_stack.top().add(node)

		return node
	}

	//new_node_from_file(filepath) { return nil }

	add_node_from_file(filepath, x, y)
	{
		var node = nil

		if (filepath.contains(".ves"))
		{
			var old_dir = Filesystem.get_asset_base_dir()
			Filesystem.set_asset_base_dir(Filesystem.get_file_dir(filepath))

			node = Subgraph()
			node.load_from_file(this, filepath)

			if (old_dir != "") {
				Filesystem.set_asset_base_dir(old_dir)
			}
		}
		else if (filepath.contains(".png") or filepath.contains(".jpg"))
		{
			node = Texture()
			var relative = Filesystem.get_relative_path(filepath)
			node.init_texture(relative)
		}
		else if (filepath.contains(".glsl") or filepath.contains(".hlsl"))
		{
			node = ShaderCode()
			var relative = Filesystem.get_relative_path(filepath)
			node.filepath = relative
		}
		else
		{
			//node = this.new_node_from_file(filepath)
		}

		if (node) {
			var pos = GUI.trans_scr_pos_to_proj(x, y, -this.camera.pos.x, -this.camera.pos.y, 1.0/this.camera.scale)
			this.add_node(node, pos[0], pos[1])
		}
	}
	
	load_file_imports()
	{
		return "
import \"blueprint.blueprint\" for Blueprint
import \"blueprint.nodes.*\"
"
	}

	loadfromstring(str)
	{
		this.clear()

		var header = "
import \"editor\" for _editor
"
		header = header + this.load_file_imports()

		var source = header + str

		Basic.loadstring("temp", source)

		this.nodes_op.comm_op.rebuild()

		this.scene_stack.bp_dirty = true

		this.scene_stack.set_root_filepath(this.filepath)
	}

	loadfromfile(filepath)
	{
		this.filepath = filepath
		return this.loadfromfile()
	}

	loadfromfile()
	{
		if (this.filepath == "") {
			return
		}

		var old_dir = Filesystem.get_asset_base_dir()
		Filesystem.set_asset_base_dir(Filesystem.get_file_dir(this.filepath))

		var file = IO.open(this.filepath, "r")
		this.loadfromstring(file.read())
		IO.close(file)

		if (old_dir != "") {
			Filesystem.set_asset_base_dir(old_dir)
		}
	}

	load_from_subgraph(subgraph)
	{
		this.filepath = subgraph.filepath
		
		for (var item in subgraph.all_items) {
			this.add_node(item[0], item[1], item[2])
		}

		this.nodes_op.comm_op.rebuild()

		this.scene_stack.bp_dirty = true
	}

	query_node_idx(node_set, bp_node)
	{
		for (var i in 0..node_set.count) {
			if (node_set[i].components["bp"] == bp_node) {
				return i
			}
		}
		return -1
	}

	savetofile()
	{
		class MemFile {
			init() { this.str = "" }
			write(str) { this.str = this.str + str }	
		}		

		var old_dir = Filesystem.get_asset_base_dir()
		Filesystem.set_asset_base_dir(Filesystem.get_file_dir(this.filepath))
		var file = IO.open(this.filepath, "w")

		if (!file.is_valid()) {
			file = MemFile()
		}

		var scene = this.scene_stack.top()

		// header
		if (file is MemFile) {
			var scene = this.scene_stack.top()
			file.write(scene.ud.import_files_header())
		} else {
			file.write(this.load_file_imports())
		}

		// nodes
		var index = 0
		for (var node in scene.nodes) 
		{
			var bp = node.components["bp"]
			var trans = node.components["transform"]

			var name = "node%(index)"

			var scope = bp.get_class().module.replace(".", "::")
			file.write("var %(name) = ::%(scope)::%(bp.get_class().name)()\n")

			var node_str = bp.to_string(name)
			file.write("%(node_str)\n")

			file.write("_editor.add_node(node%(index), %(trans.position.x), %(trans.position.y))\n\n")

			index = index + 1
		}

		// connections
		var bp_nodes = []
		for (var f_node in scene.nodes) {
			bp_nodes.add(f_node.components["bp"])		
		}
		var sorted_nodes = Blueprint.topo_sort(bp_nodes)
		for (var t_node in sorted_nodes)
		{
			var t_name = nil
			var t_idx = this.query_node_idx(scene.nodes, t_node)
			if (t_idx >= 0) {
				t_name = "node%(t_idx)"
			}
			for (var t_pin in t_node.imports)
			{
				for (var t_conn in t_pin.conns)
				{
					if (!t_conn.from.node.dummy)
					{
						var f_pin
						var f_name
						for (var f_idx = 0; f_idx < scene.nodes.count; f_idx = f_idx + 1) {
							var f_bp = scene.nodes[f_idx].components["bp"]
							if (f_bp == t_conn.from.node) {
								f_name = "node%(f_idx)"
							}
						}
						//file.write("Blueprint.connect(%(f_name).imports[%(t_conn.from.slof_idx)], %(t_name).exports[%(t_conn.to.slof_idx)])\n")
						file.write("Blueprint.connect(%(f_name), \"%(t_conn.from.name)\", %(t_name), \"%(t_conn.to.name)\")\n")
					}
				}
			}			
		}

		if (file is MemFile) 
		{
			var scene = this.scene_stack.top()
			scene.ud.file_content = file.str
		} else {
			IO.close(file)
		}

		if (old_dir != "") {
			Filesystem.set_asset_base_dir(old_dir)
		}
	}

	copy_to_clipboard()
	{
		this.clipboard = ""
		var ext_clipboard = ""

		var scene = this.scene_stack.top()

		// nodes
		for (var node in scene.selection) 
		{
			var bp = node.components["bp"]
			var index = this.query_node_idx(scene.nodes, bp)
			var trans = node.components["transform"]

			var name = nil
			if (index >= 0) {
				name = "node%(index)"
			}
			var source = "
var %(name) = %(bp.name)()
%(bp.to_string(name))
_editor.scene_stack.top().selection_add(_editor.add_node(%(name), %(trans.position.x), %(trans.position.y)))
"
			this.clipboard = this.clipboard + source
			ext_clipboard = ext_clipboard + source
		}

		// connections
		var bp_nodes = []
		for (var node in scene.selection) {
			bp_nodes.add(node.components["bp"])		
		}
		var sorted_nodes = Blueprint.topo_sort(bp_nodes)
		for (var t_node in sorted_nodes) 
		{
			var t_name = nil
			var t_idx = this.query_node_idx(scene.nodes, t_node)
			if (t_idx >= 0) {
				t_name = "node%(t_idx)"			
			}
			for (var t_pin in t_node.imports)
			{
				for (var t_conn in t_pin.conns)
				{
					var f_name = nil
					// find in selection
					for (var node in scene.selection) {
						var f_bp = node.components["bp"]
						if (f_bp == t_conn.from.node) {
							var f_idx = this.query_node_idx(scene.nodes, f_bp)
							if (f_idx >= 0) {
								f_name = "node%(f_idx)"							
							}
						}
					}
					if (f_name) {
						ext_clipboard = ext_clipboard + "Blueprint.connect(%(f_name), \"%(t_conn.from.name)\", %(t_name), \"%(t_conn.to.name)\")\n"	
					}
					
					// find in scene
					if (!f_name)
					{
						var f_idx = this.query_node_idx(scene.nodes, t_conn.from.node)
						if (f_idx >= 0) {
							f_name = "_editor.scene_stack.top().nodes[%(f_idx)].components[\"bp\"]"
						}
					}
					if (f_name) {
						this.clipboard = this.clipboard + "Blueprint.connect(%(f_name), \"%(t_conn.from.name)\", %(t_name), \"%(t_conn.to.name)\")\n"
					}
				}
			}
		}

		this.cam_pos_on_copy = Vector2(this.camera.pos.x, this.camera.pos.y)

		tt_System.set_clipboard_text(ext_clipboard)
	}

	paste_from_clipboard()
	{
		var text = this.clipboard
		if (text == "") {
			text = tt_System.get_clipboard_text()
		}
		if (text == "") {
			return
		}

		var scene = this.scene_stack.top()

		scene.selection_clear()

		var header = "
import \"editor\" for _editor
"
		header = header + this.load_file_imports()

		var source = header + text
		Basic.loadstring("temp", source)

		if (this.cam_pos_on_copy)
		{
			var dx = this.camera.pos.x - this.cam_pos_on_copy.x
			var dy = this.camera.pos.y - this.cam_pos_on_copy.y
			var trans_op = Node2dTranslate(this.camera, this.scene_stack)
			trans_op.translate(Vector2(dx, dy))
		}

		this.scene_stack.bp_dirty = true
	}

	refresh()
	{
		this.loadfromfile()
	}

	clear()
	{
		this.editop.clear()
		this.scene_stack.top().clear()

		this.script_stack = []

		this.clipboard = ""
		this.cam_pos_on_copy = nil
	}

	print_screen()
	{
		var TEX_SIZE = 512

		var img_path = this.filepath.replace(".ves", ".jpg")

		Filesystem.remove_file(img_path)

		var fbo = Framebuffer.init()

		var rbo_color = RenderBuffer.init(TEX_SIZE, TEX_SIZE, "rgb")
		fbo.attach_rbo(rbo_color, "col0")

		var rbo_depth = RenderBuffer.init(TEX_SIZE, TEX_SIZE, "depth_component")
		fbo.attach_rbo(rbo_depth, "depth")

		var prev_fbo = Render.get_fbo()
		var prev_vp = Render.get_viewport()

		Render.set_fbo(fbo)
		Render.set_viewport([ 0, 0, TEX_SIZE, TEX_SIZE ])

		this.draw_preview()

		var img = ImageData.init("SCREEN_CAPTURE")
		img.store_to_file(img_path)

		Render.set_fbo(prev_fbo)
		Render.set_viewport(prev_vp)
	}

	enter_subgraph()
	{
		var scene = this.scene_stack.top()

		if (scene.selection.count != 1) {
			return false
		}

		var node = scene.selection.front()
		var bp_node = node.components["bp"]
		if (!(bp_node is Subgraph)) {
			return false
		}

		scene.on_leave_out()

		bp_node.setup_popup_nodes(this)

		var name = Filesystem.get_filename(bp_node.filepath)
		var next_scene = Scene(name)
		next_scene.filepath = bp_node.filepath
		next_scene.ud = bp_node
		this.scene_stack.push(next_scene)
		next_scene.on_enter_in()
		if (bp_node.file_content) {
			this.filepath = ""
			this.loadfromstring(bp_node.file_content)
		} else {
			//this.loadfromfile(bp_node.filepath)
			this.load_from_subgraph(bp_node)
		}

		return true
	}

	check_and_rebuild_list()
	{
		if (this.drawlist and this.exe_list and !this.scene_stack.bp_dirty) {
			return
		}

		var scene = this.scene_stack.root()

		var nodes = []
		for (var node in scene.nodes) {
			nodes.add(node.components["bp"])
		}

		if (this.scene_stack.bp_dirty or !this.drawlist) {
			this.drawlist = Drawlist(nodes)
		}
		if (this.scene_stack.bp_dirty or !this.exe_list) {
			this.exe_list = ExecuteList(nodes)
			this.exe_list.run()
		}
		if (this.scene_stack.bp_dirty or !this.trigger_list) {
			this.trigger_list = TriggerList(nodes)
		}
	}

	draw_preview()
	{
		this.check_and_rebuild_list()

		if (!this.drawlist or !this.exe_list or this.scene_stack.bp_dirty) {
			this.scene_stack.bp_dirty = false
		}

		Graphics.on_cam_update(0, 0, 1)

		Render.clear(["color"], { "color" : [128,128,128,128] })

		this.drawlist.run()

		Graphics.flush()
		Graphics.on_cam_update(this.camera.pos.x, this.camera.pos.y, this.camera.scale)		
	}
}